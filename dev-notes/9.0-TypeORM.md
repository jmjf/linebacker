# Build adapters to connect to the database with TypeORM

For reasons, I need to support TypeORM, so build repo adapters that use it.

## Plan

My Prisma adapters probably serve as a pattern for my TypeORM adapters. TypeORM's syntax will be a bit different, but should be similar.

Basic plan:

-  Set up MSSQL docker compose (for reasons)
-  Install TypeORM
-  Define data-source and entities for TypeORM
   -  Use Prisma as a reference
-  Write a Q&D test program to confirm TypeORM can connect and write data
-  Write `TypeormBackupRequestRepo`

## Setup notes

MS SQL

-  Added `docker-compose/dev-ms.yml`
-  Added env variables to `env/dev.env`
   -  MSSQL_SA_PASSWORD="pick_your_password"
   -  ACCEPT_EULA="Y"
-  Tried to use volumes, but had issues, so commented out
-  Got SQL Server running and used Adminer to create a database
-  Tried to setup a login and user, but couldn't grant permissions, so will use sa for now
-  Added env variables to use for TypeORM
   -  SQLSERVER_USER=sa
   -  SQLSERVER_PASSWORD=pick_your_password
   -  SQLSERVER_DB=linebacker
   -  SQLSERVER_SCHEMA=lb

TypeORM

-  Referring to an install in a clean directory to find what I really need
-  `npm install typeorm mssql reflect-metadata`
-  Add to `tsconfig.json`
   -  "emitDecoratorMetadata": true
   -  "experimentalDecorators": true
   -  "strictPropertyInitialization": false
-  Create `/src/typeorm`, `/src/typeorm/entity`, `/src/typeorm/migration`
-  Create `/src/typeorm/dataSource.ts`
-  Create `.../entity/BackupRequest.entity.ts`
-  `npx typeorm migration:create src/typeorm/migration/backupRequest`
-  Build `.../migration/BackupRequest.sql` to create the table because I don't want TypeORM controlling the database structure
   -  Schema doesn't seem to work as expected, so just use dbo
-  Write test program `src/toTest.ts`

Errors encountered

-  TypeScript wouldn't compile entity
   -  Add to `tsconfig.json` -> `"strictPropertyInitialization": false`
-  Self-signed certificate error
   -  Add option to `toDataSource` -> `encrypted: false`
   -  TypeORM won't pass through `trustServerCertificate: true`
-  Can't connected because user is ''
   -  Load environment before importing `toDataSource`
-  Columns aren't nullable (apparently NOT NULL is the default)
   -  Add explicit NULL to SQL
   -  Alter table to make columns nullable

It works.

**COMMIT: CHORE: Get TypeORM functioning with MSSQL so I can begin developing with it**

## SQL Server improvements

Data doesn't persist after stopping the containers, so some more digging led me to an answer. The SQL Server 2019 image starts as non-root, so can't create anything. I found several possible solutions, but opted to add `user: root` to the container startup so it runs as root (easy, adequate).

I also figured out the login/user thing.

-  `create login linebacker with password='choose_your_password'` -- Use this id & pw
-  `use linebacker` to be in the linebacker database.
-  `create user lbuser for login linebacker` to create lbuser attached to the linebacker login
-  `EXEC sp_addrolemember 'db_datawriter', 'lbuser'` and same with `db_datareader` to give permissions at the database level
   -  I'll create tables myself instead of using migrations; more work, but more real world

Added SQLSERVER_URL and SQLSERVER_PORT to env and used them in `toDataSource`. I want to find a better env solution, but that's not immediate focus.

**COMMIT: CHORE: SQL Server setup improvements**

## Write TypeormBackupRequestRepo

-  Copy `PrismaBackupRequestRepo`
-  Import `typeorm` and `TypeormBackupRequest`
-  Replace Prisma bits with TypeORM bits
-  Change functions to use TypeORM calls
-  Add logging until I confirm everything is working

### Get CreateBackupRequestUseCase tests working with TypeORM

-  Copy `CreateBackupRequestUseCase.spec.ts` to `...Case.typeorm.spec.ts`
-  Comment out all tests except the first (start with one)
-  Replace Prisma with TypeORM, including imports
-  Import `mockDeep` from `jest-mock-extended`
   -  Look closer at how prismaCtx setup works and if it makes sense to do something similar later
-  In the test, use `mockDeep` to mock `EntityManager`. `...ger.save.mockResolvedValueOnce` with `{}` to pass test
-  Use the TypeORM version of the repo
-  Run the test and see it pass

It works. That was easier than I expected.

### Get CheckRequestAllowedUseCase tests working with TypeORM

-  Follow same pattern as above.

Tests are passing.

### Build a TypeORM context like Prisma context I used

-  Create `src/common/infrastructure/db/typeormContext.ts`
-  Replace Prisma with TypeORM
   -  I've set it up to use `EntityManager` because I don't want to build my repo's intellgence into a TypeORM construct (Repository/CustomRepository) and bind myself to TypeORM. Moving from Prisma to TypeORM has proved simple so far because the repo intelligence for Prisma was completely outside Prisma constructs.
-  Change test setup for `CreateBackupRequestUseCase.typeorm.spec.ts`
   -  Don't import from `jest-mock-extended` -- that happens in the context setup
   -  Replace Prisma reference with TypeORM references

In the repo (adapter)

```typescript
import { TypeormContext } from '..../common/infrastructure/db/typeormContext';

export class TypeormBackupRequestRepo implements IBackupRequestRepo {
	private typeormCtx: TypeormContext;

	constructor(typeormCtx: TypeormContext) {
		// Use TypeORM's EntityManager because I don't want to put my repo intelligence in
		// a TypeORM construct because doing so creates tight coupling to TypeORM.
		this.typeormCtx = typeormCtx;
	}

	...

	// in save, for example
	try {
			await this.typeormCtx.manager.save(TypeormBackupRequest, { ...raw });
		} catch (e) {
			...
		}

	...
}
```

In tests, we have `mockTypeormCtx`, which looks like a jest mockable object and `typeormCtx`, which does not, and point them to the same thing. We use `mockTypeormCtx` to mock behavior, but pass `typeormCtx` to the repo constructor so it isn't aware of the extra functionality jest adds so the test is as close to real as possible while remaining a unit test (does not connect to a database).

```typescript
import {
	MockTypeormContext,
	TypeormContext,
	createMockTypeormContext,
} from '../../../common/infrastructure/database/typeormContext';

describe('CreateBackupRequestUseCase.typeorm', () => {
	let mockTypeormCtx: MockTypeormContext;
	let typeormCtx: TypeormContext;

	beforeEach(() => {
		// use mock context as the real context
		mockTypeormCtx = createMockTypeormContext();
		typeormCtx = mockTypeormCtx as unknown as TypeormContext;
	});

	...

	test(`test that doesn't need to mock a database call`, async () => {
		// const entityManager = mockDeep<EntityManager>(); not needed
		// test does not call database, so no need to mock any results
		const repo = new TypeormBackupRequestRepo(typeormCtx);

	...

	});

	test(`test that needs to mock a database call`, async () => {
		// mockTypeormCtx supports jest mock methods; typeormCtx does not
		// beforeEach makes typeormCtx = mockTypeormCtx, so mocks on mockTypeormCtx
		// also apply to typeormCtx IN THE TEST
		mockTypeormCtx.manager.save.mockResolvedValueOnce({} as TypeormBackupRequest);

		const repo = new TypeormBackupRequestRepo(typeormCtx);

	...

	});
});
```

In application setup

```typescript
// In typeormDataSource, export const typeormDataSource = new DataSource({ ... });
import { typeormDataSource } from '..../typeormDataSource';

// Import typeormDataSource before typeormContext; context uses data source.
// We don't call getMockTypeormContext(), so this is the real context.
import { typeormCtx } from '..../common/infrastructure/db/typeormContext';

...

const startServer = async () => {

	...

	await typeormDataSource.initialize();

	const server = buildApp(typeormCtx);

}

// in module init, which I do in "add routes" for each module

export const initXyzModule = (typeormCtx: TypeormContext, ... ) {

	const xyzRepo = new TypeormXyzRepo(typeormCtx);
	const useCase1 = new UseCase1(xyz)

	...

}
```

### Get SendToInterface tests working with TypeORM

With the setup above, this change was very easy.

-  Remap prisma/Prisma names to typeorm/Typeorm names
-  Adjust function names for mock to match TypeORM's API
-  Replace 'BackupRequest' type in database related mock data with 'TypeormBackupRequest'
   -  Need to rename Prisma entities to `Prisma...` to avoid confusion with application entities/aggregates

Tests pass.

I'm calling this a FEAT because I'm leaving the code in a position to run with either TypeORM or Prisma. I'm not removing/replacing Prisma, creating refactored copies of the code for TypeORM to demonstrate how flexible this approach is.

**COMMIT: FEAT: add TypeORM support for BackupRequest**

## Backup and remaining tests

The remaining tests require a `TypeormBackup` entity and a `TypeormBackupRepo`, among other things maybe. Because they're require working out of the `backup-request` module, I'm putting them in a separate commit to the branch.

I could leave the `Backup` parts on Prisma for now, but I think it will be easier to clean things up if I do all the work related to them in one shot.

### Add TypeormBackup entity

### Build TypeormBackupRepo

### Get ReceiveStoreStatusReply tests working with TypeORM

### Get testEvents tests working with TypeORM

`
