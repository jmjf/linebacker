## Build test-events for BullMQ

## Planning

Let's walk through how it works to understand how we might test.

-  Accepted use case publishes an event
   -  Need to mock BMQ add to return ok
-  To run the Receive use case, I need
   -  A `BullmqConsumer` for the use case
   -  A BMQ `Job` based on the event
   -  To pass the `Job` to the consumer
   -  Consumer calls the use case, which will publish an event
      -  "add ok" mock should still be good
-  To run the other use cases, I need
   -  Same as above
-  Would like to have a generic "event to `Job`" method so I don't need to manually construct `Job` instances.

The `Job` constructor signature is:

```typescript
new Job<DataType, ReturnType, NameType>(queue: MinimalQueue, name: NameType, data: DataType, opts?: JobsOptions, id?: string): Job<DataType, ReturnType, NameType>
```

I think the `MinimalQueue` will be the most challenging bit to fake.

Or I could write a function to return `Job` from a name, id and data

-  Would be incomplete, but complete enough for the consumer
-  `data` is the whole event, including `data.event`, which is the actual data to pass to the use case
-  Consumer cares about `name`, `id`, `data` and `attemptsMade` members

If we write it like the in-memory `test-events` only need to test the success case.

-  The goal of `test-events` is to test the flow through all the use cases
-  `BullmqConsumer` is generic to all consumers, so if it works for one, it works for all
-  But maybe should have tests for throw cases for the consumer to ensure they behave as expected
