# Build a better solution for app configuration from the env data

## Plan

-  Create a configuration object singleton that builds itself from `process.env`
   -  Move all `process.env` values that matter, `dotenv`, etc., into the singleton
   -  Structure it sanely; use everywhere
   -  Revamp `.env` files as needed
   -  For BullMq/Redis
      -  Queue settings are hard coded in `publish`; retry count should be large
      -  Custom backoff policy that increments to a max and then stays at that max
      -  Connection details
-  In `AzureQueue.receiveMessages()`, make the visibility timeout configurable
   -  From environment or from caller as a parameter (TBD)

## Configuration object

The basic structure of the object is based on env other data. For example, if I need credentials to communicate with other applications or services and if any of those credentials could expire, I need a way to return a valid credential (return cached value or get a fresh value if expired).

The main thing to test is that the strategy for providing values when none exist works. That may be too trivial to test in most cases.

I'll call the object `appState`. In line with 12 factor "stateless" ideology, everything in `appState` is transient. It should be recoverable from other sources or replaceable on startup. For example, env values from a file, credentials from a credential provider, etc.

I'll have one `appState` that carries state for all sub-applications.

## Notes

-  Created `src/infrastructure/appState/appState.ts`
-  `buildAppState` reads env file, checks for required env values, builds and returns `appState`
   -  If `APP_ENV` is not set, assumes the env is set from the OS or similar
   -  If required env values are missing, returns false
-  Module includes helper functions to ensure values are set sanely

Problem: `buildAppState` takes parameter that vary by sub-app. That means the sub-app's server module needs to create `appState` and export it. Importing that everywhere feels odd--maybe.

Having thought about it a while, I need to build and export `appState` so I don't need sub-app specific instances. Each sub-app can check `appState` usability with a simple scan of keys based on an array. So, instead of checking then building, build `appState` and call a function to ensure required members are present. I can export the function from `appState` using logic similar to what I have in the build function now.

-  Changed `appState`
   -  To better support required value checking, flatten the structure because I don't want to deal with object traversal
-  Added exported function `isAppStateUsable(service: string, feature: string, requiredMembers: string[]): boolean`
   -  Logs and returns false if one or more required members is:
      -  undefined
      -  null
      -  empty string
      -  not a number
      -  an empty array
   -  The sub-app startup/server should call this method on startup to ensure `appState` has required env values set
-  In `rcvSrvExpTypeorm.ts`, add checks for `isAppStateUsable` and use `appState`
-  In `rcvAppExpTypeorm.ts`, use `appState`
-  Get it to run
   -  Required some fixes in `isAppStateUseable` and correcting a couple of the names passed to it
-  Do the same with `api...` and `bmqWorker`
-  Use `appState` in `typeormDataSource` and see it work
-  Improve `appState` with logic to handle BullMQ "RemoveOn" environment values
-  Change `queue-helper` to use `appState`
-  Change `AzureQueue` to use `appState`
   -  Instead of `DefaultAzureCredential`, which requires specific env names, use `ClientSecretCredential`
   -  Change 'ADCC' to 'client-secret' (case insensitive)
-  Confirmed `pinoLogger` can't use `appState` because it creates a definition priority problem for values
   -  In `pinoLogger` use env directly with a default
   -  In `appState` use `logger.level` to get the `appState` value
   -  If changing log levels by api enabled in the future, set `appState` and `logger`; may become a method somewhere
   -  This means `pinoLogger` can control log level more flexibly, so doesn't use `isDev()`

Not changed:

-  `pstBin.ts`
-  Prisma startup
-  Fastify startup
-  `localQueue.ts`
-  zpages routes that use pm2 values for health/statistics info (only used here and not really env we care about)
-  `isDev()` and `isTest()` because they rely on values not in `appState` (`APP_ENV`, `NODE_ENV`, `JEST_WORKER_ID`)

Code runs and works, so this seems to be good.

**COMMIT: REFACTOR: rebuild appState code to remove problems with first design; change application components to use it**

## TODO

-  change tests that use 'ADCC', set env directly, etc.
-  change auth to use an array of issuers (or is it already)
-  prefix all env file variable names consistently; consider some renames
-  [x] change queue auth to use a specific credential type so it can get values from `appState`; add values to `appState`
-  [x] move BMQ remove-on logic into `appState`
-  [x] can `appState` import logger without creating a circular reference situation -- nope, doesn't work
-  put more controls around `appState` to manage changes ????
