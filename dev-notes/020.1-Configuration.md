# Build a better solution for app configuration from the env data

## Plan

-  Create a configuration object singleton that builds itself from `process.env`
   -  Move all `process.env` values that matter, `dotenv`, etc., into the singleton
   -  Structure it sanely; use everywhere
   -  Revamp `.env` files as needed
   -  For BullMq/Redis
      -  Queue settings are hard coded in `publish`; retry count should be large
      -  Custom backoff policy that increments to a max and then stays at that max
      -  Connection details
-  In `AzureQueue.receiveMessages()`, make the visibility timeout configurable
   -  From environment or from caller as a parameter (TBD)

## Configuration object

The basic structure of the object is based on env other data. For example, if I need credentials to communicate with other applications or services and if any of those credentials could expire, I need a way to return a valid credential (return cached value or get a fresh value if expired).

The main thing to test is that the strategy for providing values when none exist works. That may be too trivial to test in most cases.

I'll call the object `appState`. In line with 12 factor "stateless" ideology, everything in `appState` is transient. It should be recoverable from other sources or replaceable on startup. For example, env values from a file, credentials from a credential provider, etc.

I'll have one `appState` that carries state for all sub-applications.

## Notes

-  Created `src/infrastructure/appState/appState.ts`
-  `buildAppState` reads env file, checks for required env values, builds and returns `appState`
   -  If `APP_ENV` is not set, assumes the env is set from the OS or similar
   -  If required env values are missing, returns false
-  Module includes helper functions to ensure values are set sanely

Problem: `buildAppState` takes parameter that vary by sub-app. That means the sub-app's server module needs to create `appState` and export it. Importing that everywhere feels odd--maybe.

Having thought about it a while, I need to build and export `appState` so I don't need sub-app specific instances. Each sub-app can check `appState` usability with a simple scan of keys based on an array. So, instead of checking then building, build `appState` and call a function to ensure required members are present. I can export the function from `appState` using logic similar to what I have in the build function now.

-  Changed `appState`
   -  To better support required value checking, flatten the structure because I don't want to deal with object traversal
-  Added exported function `isAppStateUsable(service: string, feature: string, requiredMembers: string[]): boolean`
   -  Logs and returns false if one or more required members is:
      -  undefined
      -  null
      -  empty string
      -  not a number
      -  an empty array
   -  The sub-app startup/server should call this method on startup to ensure `appState` has required env values set
-  In `rcvSrvExpTypeorm.ts`, add checks for `isAppStateUsable` and use `appState`
-  In `rcvAppExpTypeorm.ts`, use `appState`
-  Get it to run
   -  Required some fixes in `isAppStateUseable` and correcting a couple of the names passed to it
-  Do the same with `api...` and `bmqWorker`
-  Use `appState` in `typeormDataSource` and see it work
-  Improve `appState` with logic to handle BullMQ "RemoveOn" environment values
-  Change `queue-helper` to use `appState`
-  Change `AzureQueue` to use `appState`
   -  Instead of `DefaultAzureCredential`, which requires specific env names, use `ClientSecretCredential`
   -  Change 'ADCC' to 'client-secret' (case insensitive)
-  Confirmed `pinoLogger` can't use `appState` because it creates a definition priority problem for values
   -  In `pinoLogger` use env directly with a default
   -  In `appState` use `logger.level` to get the `appState` value
   -  If changing log levels by api enabled in the future, set `appState` and `logger`; may become a method somewhere
   -  This means `pinoLogger` can control log level more flexibly, so doesn't use `isDev()`

Not changed:

-  `pstBin.ts`
-  Prisma startup
-  Fastify startup
-  `localQueue.ts`
-  zpages routes that use pm2 values for health/statistics info (only used here and not really env we care about)
-  `isDev()` and `isTest()` because they rely on values not in `appState` (`APP_ENV`, `NODE_ENV`, `JEST_WORKER_ID`)

Code runs and works, so this seems to be good.

**COMMIT: REFACTOR: rebuild appState code to remove problems with first design; change application components to use it**

## Testing with appState

First, check auth to be sure it takes an array of issuers. It does, but the check could be better, so add `Array.isArray()` to the condition.

Thinking about how this works, `appState` is an exported constant object (like a C `struct` really). I should be able to override it in tests by changing properties. I need to think about that, given the TODO item that suggests protecting `appState` from unsafe changes. If I do that, changing it in tests might be harder.

But I don't want to pass `appState` everywhere (might be an argument for a dependency injection container library, which would help other places we're passing lots of stuff). That's a bigger issue, so for now, let's assume any protecting of `appState` will allow changes if needed.

WWhat env values are unit tests setting today?

-  `EVENT_BUS_TYPE` (all around BullMQ)
-  Azure Queue env values (many places)
   -  Most are using SASK type because it's easier to set up

I'll work on an event bus test first (`ExpressAcceptBackupRequestController`) because those tests use only one value, unless they also use Azure Queue.

Currently, the test sets `process.env.EVENT_BUS_TYPE` at the top of the test. That probably won't work well. So, let's set `appState.eventBus_type` in the test. And the best place to do that for this test is probably in `beforeEach`.

-  A couple of tests are failing
-  Database error is getting a 202 instead of a 500
   -  It returns 202 if the use case is ok, otherwise, it should return some kind of error
   -  The use case calls the event bus (not database, so test name is wrong)
   -  The test is mocking the BullMQ `add` function (correct)
   -  May need to set `appState` at the top instead of in `beforeEach` because the event bus instance is determined by it
   -  That fixes it
   -  So, I get away from setting `process.env` in tests, which is probably good, but still need to set it at the top for event bus

I'll change the rest of the event bus tests now. After changes, 37 tests are failing, but they're all Azure Queue related.

**COMMIT: TEST: (some tests failing) change tests that use env EVENT_BUS_TYPE to use appState**

## TODO

-  change tests that use 'ADCC', set env directly, etc.
-  [x] change auth to use an array of issuers (or is it already)
-  prefix all env file variable names consistently; consider some renames
-  [x] change queue auth to use a specific credential type so it can get values from `appState`; add values to `appState`
-  [x] move BMQ remove-on logic into `appState`
-  [x] can `appState` import logger without creating a circular reference situation -- nope, doesn't work
-  put more controls around `appState` to manage changes ????
