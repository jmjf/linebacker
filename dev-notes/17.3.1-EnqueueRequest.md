# Build EnqueueBackupRequestUseCase and tie it to the controller

### What does it do?

-  Receives an HTTP call from a controller; rename `ExpressCreateBackupRequestController` and change the use case it calls
-  Call `BackupRequest.create()` to confirm the request can be created; goal is to detect errors here so we can respond to the caller
-  Add the request to the `ReceivedBackupRequests` queue

### What does it need

-  New use case
-  An adapter for BullMQ that can add an event to a queue; get the queue name from the event
   -  mapToQueue function
-  An event type for `BackupRequestReceived`

For unit tests, I need a way to mock BullMQ. Will probably be similar to how I mock @azure/storage-queue.

For checking purposes, I need a way to see what's in the queue. In the application, BullMQ queue watchers will be based on the BullMQ `Worker`

### What can go right? What can go wrong?

-  when the request cannot be created, it returns a PropsError
   -  The controller should return 400 Bad Request, which it already does for PropsError
-  when the request cannot be added to the queue, it returns a EventBusError
   -  The controller should return 500 Server Error
   -  EventBusError replaces DatabaseError as a possible return
   -  Need to understand what BullMQ returns on error to decide how to structure the error data for logs
-  when the request is added to the queue, it returns ok and the request data enqueued
   -  Request data enqueued will include request id, backup job id, data date, received timestamp (data returned to tenant)

### Notes

-  Copy `CreateBackupRequest` DTO, tests, and use case to `enqueue-backup-request`.
-  Rename files and classes.
-  Create `IBackupRequestEventBus` interface for the adapter.
-  Create `AdapterErrors.EventBusError`; for now, `add` returns whatever was passed as `ok()`
-  Mock BullMQ in tests. Pass to adapter; add adapter constructor to pass it
   -  Not used yet, but let's set up like we know it will be
   -  I'll need to create the queue so I can add to it (`new Queue(queueName)`) .. but, some trial and reading later, the way I'm using `jest.mock`, it mocks the constructor for me, so my mock BullMQ isn't trying to call redis.

Tests are working.

**COMMIT: FEAT: add EnqueueBackupRequestUseCase, BullMQ adapter; tests passing**

-  Copied the "create" controller and changed to enqueue
-  Added enqueue to the init module and routes
-  Split database, Splunk, Redis into different Docker ymls
-  Added `bullMqInfra`, not sure this will stick, but for now it's good
-  Wrote a simple test to prove BullMQ works
-  Changed test to read data from queue and log it

Ran the application and posted 3 requests. Ran test reader and saw the data hit the queue.

So, the basic structure is working.

Enqueue controller is not passing tests because something isn't handling errors correctly.
Create controller is not passing tests but will probably go away in the future.

**COMMIT: FEAT: add controller, wire into the API; see it connect and move data**

NEXT

-  Fix controller tests (probably need better error handling in event bus)
-  Pass queue name to the event bus methods
-  Decide how to name jobs (understand implications)
-  Do I need a mapping function? Or functions? Or will I treat the queue data as a reliable DTO?
-  Is there a way to detect that an add request failed due to a connect error?
   -  I won't need DER in the future, but a simpler CircuitBreaker would be good (mediate connections)
