# Add a controller or similar for `ReceiveCreateBackupReplyUseCase`

## Plan
The high level design for the system wants to receive replies on a message queue of some kind. I'm using Azure storage queues and, specifically, Azurite, a local emulator for Azure storage. Other options include Kafka, RabbitMQ, NATS, or any of several other queue/message broker systems. The key requirement for any such system is that messages that the message processor doesn't delete from the queue reappear on the queue after a timeout, which allows the system to recover from cases where the message processor fails mid-processing.

This direction introduces a few considerations.

### Idempotence for partial database updates
* The use case will update two aggregates (`Backup` and `BackupRequest`), which means two database updates. I'm not planning to make those updates a single transaction.
* I will require `Backup` to complete before updating `BackupRequest`. A `BackupRequest` that succeeds isn't considered successful until the `Backup` exists in the database.
* If the `BackupRequest` update fails, the "controller" won't delete the message from the queue. The same message will return later. I need to handle duplicate messages sanely.
* So, the use case should check if a `Backup` already exists for the `backupRequestIdentifier`. If so, don't touch the `Backup` because it may have been updated by other processes after it was written. Consider the `Backup` save successful and go on to the `BackupRequest`.

### Idempotence for duplicate messages
* The use case's database updates could success, but the "controller" could fail to delete the message (connection failure or similar).
* The "partial database updates" situation keeps `Backup` safe.
* If `BackupRequest` is in a completed status, don't update it and consider it successful.
* In fact, maybe that should be a first check? Or should I allow for the possibility that some idiot will do a backend update to `BackupRequest` when the `Backup` isn't written? Probably. I know too many people who think backend updates are the solution to all problems, not recognizing that they're the cause of many problems. Let's idiot proof as much as we can.

### Polling vs. notification
   * Different queue/message broker systems work in different ways. Some require the client to poll the queue to get messages. Others allow the client to register a handler and call that handler (RPC, basically), or hide the polling nature of the interface in a function that polls behind the scenes.
   * Azure storage queues require the client to poll, so the "controller" will be a polling loop that calls the use case to handle any messages it receives. I have an Azure queue listener in another learning project I did, so will adapt it to `linebacker`. 
      * Previous work passes the message body as a string. For `linebacker`, I'll need to convert the string to the expected DTO.
      * Previous work puts messages that fail several times on a poison (Azure) queue. `linebacker` may log them instead.
   * In the future, I may try other queue options to learn about them.

## Next steps
* Ensure the use case handles idempotence for partial updates.
   * Test to simulate `Backup` exists and ensure the repo's `save()` isn't called.
* Ensure the use case handles idempotence for duplicate messages.
   * Test to simulate `Backup` exists and `BackupRequest` completed, neither `save()` is called, returns okay.
   * Test to simulate `Backup` does not exist and `BackupRequest` completed, `Backup` `save()` is called, `BackupRequest` `save()` is not called, returns okay.
* Adapt existing queue code to run the polling loop.
   * Review queue code and think about how to make it better. Managing the queue is somewhat complex.
   * Think about how to deal with no message on the queue. (Currently, code waits longer each time up to a max wait.)
   * Same polling loop with a different use case handler, so try to build a generic loop you can reuse in `common/infrastructure`.
   * Loop function should get a mapper function that converts the message string to the DTO and handles basic errors.
* Ensure the code deals with cannot connect to queue case.
   * I want something like a circuit breaker. What are my options?

## Idempotence for partial updates

I need the following tests for the `ReceiveCreateBackupReplyUseCase`
* `Backup` `save()` fails, `BackupRequest` `save()` isn't called and returns `Err`
* `Backup` `save()` succeeds but `BackupRequest` `save()` fails, returns `Err`
* Both `save()`s succeed, returns `Ok`
* `Backup` exists and `BackupRequest` isn't complete, `Backup` `save()` isn't called, `BackupRequest` `save()` is called (succeeds), returns `Ok`
* `Backup` exists and `BackupRequest` isn't complete, `Backup` `save()` isn't called, `BackupRequest` `save()` is called (fails), returns `Err`

And I need to ensure the use case passes these tests (after proving they can fail). All cases are for a successful result. Failed results shouldn't save a `Backup`.

I have a test that probably needs to be replaced because it says, "If the `BackupRequest` is completed, I should not update the `Backup`."
```typescript
test.each([
      RequestStatusTypeValues.Succeeded,
      RequestStatusTypeValues.Failed
   ])('when request is %p, it returns ok with unchanged status and timestamp'
```
This test isn't a problem for partial update idempotence, maybe, but is a problem for duplicate message idempotence.

I think the following test as written is a problem for partial update idempotence, because I could have a successful reply that updates `BackupRequest` only. This case requires updates to both.
```typescript
test('when result type is Succeeded, it saves the request and the backup record'
```
The tests described at the start of this section replace this test. Specifically, this test is more or less the third test in the list (both `save()`s succeed).

I'll start with the first case in the list (reply succeeded, `Backup` `save()` fails).

NOTE: To test a Prisma database operation failed, `mockRejectedValue()` as shown. Other Prisma error types might apply. See the [error reference](https://www.prisma.io/docs/reference/api-reference/error-reference):
```typescript
mockPrismaCtx.prisma.backup.upsert.mockRejectedValue(new PrismaClientKnownRequestError('Some upsert failure', prismaCode, '2'));
```

First run of the test is getting `result.isErr()` as false, so the test can fail. Now let's make the use case pass.

Instead of just calling `save()` and ignoring the result, check for an error and return it. Test passes.

Now, let's do `Backup` `save()` succeeds but `BackupRequest` `save()` fails. Here, `backupRequest.upsert.mockRejectedValue()` and `backup.upsert.mockResolvedValue({} as Backup)`. The `save()` function ignores `backup.upsert` success values, so `{}` works here.

The test fails because `result.isErr()` is false, as expected. Let's make the use case pass by checking the result of `save()` and return if `isErr()`.

Now, let's change the "when result type is Succeeded" test to be the third test.

I've decided to group tests with `describe()`s inside the main `describe()` because this use case will have a lot of tests. Grouping them makes it easier to see what's failing and helps reason about it by assigning it to a general category.

**COMMIT 6.2.1 - FEAT: support first 3 partial update idempotence requirements; tests, code**