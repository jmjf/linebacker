# Add `FastifyBackupRequestController`

## Plan
* 6.1.1 - `FastifyCreateBackupRequestController` (rename).
   * Figure out how to test for `InvalidApiVersionError`.
   * Add tests for other test conditions
      * Invalid properties get `PropsError` (how many props to test?)
      * Other use case failures get ServerError and the enclosed error is the proper type.
      * If all is good, get the expected reply value
   * Can (should) I replace some or all use case tests with controller tests?

**COMMIT 6.1.1 - REFACTOR: Rename `CreateBackupRequestFastifyController` to align with infra-first naming pattern used for Prisma repos**

## Use Prisma repo in test
* Add Prisma imports
* Remove `IBackupRequestRepo` import
* Add `let` and `beforeEach()` setup
* Create repo, use case, controller

Doesn't fail tests, but isn't testing anything yet. But getting the test working needs several steps.

**COMMIT 6.1.2 - TEST: Set up controller test to use Prisma repo**

## Set up routes
In 4.2, I looked a how Stemmler and Bazaglia set up routes. I decided to create a single route file for each application module (backup-request, being the one in scope for now). The list below, from 4.2, seems good.

[x] Add `backup-request/infrastructure/http/fastifyRoutes.ts`
   * It should add a route to the controller.
   * Needs a `FastifyInstance` and `PrismaContext` so it can set up repos, use cases, controllers and add to the `FastifyInstance`
[x] Add `app.ts` in `src` based on `zz-learn-fastify/index.ts`
   * `server.ts` can wait until we're ready to test the server
[x] Create route for `POST backup-request` to call controller
   * Look at how Stemmler is managing routes
   * Look at [`fastify.route()`](https://www.fastify.io/docs/latest/Reference/Routes/#full-declaration)

I ran into some issues with types. VS Code says, `FastifyInstance`, `FastifyRequest`, and `FastifyReply` have a long list of generic types after then and isn't happy without them. Treating the result of `fastify(opts)` as a plain `FastifyInstance` isn't accepted. I'm not sure if that's a problem in the published types or something else going on.

I defined and exported types `RealFastifyInstance`, `RealFastifyRequest` and `RealFastifyReply` in `src/common/adapter/FastifyController.ts` (base controller) and used them everywhere in place of the base types.

After excluding `src/zz-learn-fastify` in `tsconfig.json`, everything compiles, which is as far as I can test it right now. (I'm keeping `src/zz-learn-fastify` in the repo for reference. Will remove later.)

For now, I'm not using `fastify.route()` or `app.route()` to add routes to the application. If I did, the route definition function would return an array of routes. `appBuild()` would combine all the route arrays and `forEach()` over it to call `app.route()` for each route. Also, be aware of possible type issues where the base type requires a list of generics after it to actually work.

**COMMIT: 6.1.3 - FEAT: create app setup function and route for CreateBackupRequestController**

## Get fastify into the test
According to the [testing guide](https://www.fastify.io/docs/latest/Guides/Testing/), I need to import `appBuild()` into the test, initialize the app and `await app.inject()`.

Reversed the parameters to `buildApp()` so `prismaCtx` is first because it is required, while `opts` is optional.

Here's the arrange and act code for the first test.

```typescript
   // Arrange
   const app = buildApp(prismaCtx);

   // Act
   const response = await app.inject({
      method: 'POST',
      url: '/backup-request',
      payload: {
         ...baseBody,
         apiVersion: 'invalid'
      }
   });
```

After about an hour of tracing, I figured out that `FastifyController` (base controller in `commmon`) was not returning the result of executing the controller, hence was getting no result back to the route. Added a `return` in front of the call to execute the controller and it worked.

Added logging to the route if the result is an error (`statusCode > 399`).

When testing errors, I need to check the body for a string matching the error message I expect. I thought the response body for an error would be an object, but the types say it's a string, so I can't reference `message`. I could try to `JSON.parse()`, but that will throw if the response isn't an object string. So, I wrapped it in a `try ... catch` with the `catch` forcing a test failure because this test expects an error, which means an object string.

Tested failure by commenting out `apiVersion: 'invalid'` in the `app.inject()` call. (Result was a good result, so test fails.)

**COMMIT: 6.1.4 - TEST: get the "invalid apiVersion" test failing and passing**

## Test plan notes from 4.2
* when the use case has an unexpected failure, it returns 500 and an error
  * expect `reply.stausCode` 500
  * expect `result.error.message` to exist
* when the request is good, it returns 200 and response data
  * expect `reply.statusCode` 200
  * expect `result.value.requestId` to be a UUID
  * expect `result.value.statusTypeCode` to be `Received`
  * expect `result.value.receivedTimestamp` to be between `startTimestamp` and now

Also looks like I may have a `PropsError` test case (400, bad request)