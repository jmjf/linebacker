# Add CreateBackupRequestController

## Plan
* Rename `create-request` and `CreateRequest*.ts` to `create-backup-request` and `CreateBackupRequest*.ts`
* Can I write tests for the controller? Can they replace the tests for the use cases?
  * If can write tests, do so. Adjust tests as needed.
* Write the controller
* Replace controller in `zz-learn-fastify`

## Rename "create request" to "create backup request"

**Purpose:** Rename all "create request" to "create backup request"

**Why:** I'll need a way to track "create backup," "delete backup," and "restore backup" requests and their progress through the system. Name everything to be explicit about the type of request involved.

[x] Rename `create-request` to `create-backup-request`
[x] Rename `CreateRequest*.ts` to `CreateBackupRequest*.ts`
[x] Remove `apiVersion` from the DTO--the controller will map api versions to the DTO
[x] Ensure all references still work (walk through files)
[x] Ensure all tests run

**COMMIT: 4.2.1 - REFACTOR: create request -> create backup request**

## Write tests for the controller ???

I think I can. Those tests might be able to replace the unit tests for the use cases, but I think I'll keep the use case tests for now because controllers are more closely related to concerns outside of the bounded context (application + domain layer).

Considerations:
* Stemmler's controllers aren't testable because they return directly to the caller.
* Bazaglia seems to follow a similar pattern.

But I want to have automated tests in place for the API returns, so I'm going to figure out how to do it.
* Testing requires putting data in a `FastifyRequest` and reading data off of a `FastifyReply` to validate.
* I think I can have the controller return a response that the route can then `reply.send()` to close out the request.
* Then the test can inspect values on the `FastifyReply` and the returned value.
* At least, I think that will work. I'm going to find out.

### Can I set up the reply in the controller and return the data to send to the route?
[x] Change hello world controller to set up the reply and return data
[x] Change hello world route to get the result, log it, and `reply.send()` it
[x] Test with `curl`
  * Seems to be basically working, but...returns `{value: { ... }}` and log isn't handling objects well
[x] Change controller to return `result.value` or `result.error`
[x] Change logging in route

This works, so let's go with that strategy.

**COMMIT: 4.2.2 - TEST: controller sets up but route actually responds (enables testing controllers)**

### Tests
* when `apiVersion` is not a known apiVersion, it returns 400 and an error
  * expect `reply.statusCode` 400
  * expect `result.error.message` toMatch `apiVersion` and `missing or invalid`
* when the use case has an unexpected failure, it returns 500 and an error
  * expect `reply.stausCode` 500
  * expect `result.error.message` to exist
* when the request is good, it returns 200 and response data
  * expect `reply.statusCode` 200
  * expect `result.value.requestId` to be a UUID
  * expect `result.value.statusTypeCode` to be `Received`
  * expect `result.value.receivedTimestamp` to be between `startTimestamp` and now
### What to do
[] Write `FastifyController` class (base class all `fastify` controllers derive from)
  * Include what you know you need right now, add to it later
[] Write shell `CreateBackupRequestFastifyController` that does nothing
  * Tests will need it, but it does nothing so they'll fail
  * `...FastifyController` because I could have other controllers for different frameworks, queues, etc.
[] Write test for invalid `apiVersion`; watch it fail
[] Write code to test for invalid `apiVersion` and return error
[] Confirm test passes
[] Write test for 500; watch it fail
[] Code to pass test
[] Write test for request is good; watch it fail
[] Code to pass test

## Replace controller in `zz-learn-fastify`
