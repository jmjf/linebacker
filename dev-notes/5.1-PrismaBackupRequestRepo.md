# Prisma BackupRequest repo

## Create the repo

I want to write a repo using Prisma so I can save data in the database.

[x] Create `src/backup-request/adapter/impl/PrismaBackupRequestRepo.ts`
[x] The class implements `IBackupRequestRepo`
[x] Write the `save()` method (it's the one I use in tests right now, so should be able to get data I can see)
   * use `upsert()`
[x] Write the `exists()` and `findById()` methods to fulfill the interface
[x] Write `mapToDomain()` and `mapToDb()` to translate between domain and raw/db

`exists()` should return a `Result<boolean, DatabaseError>` but I don't want to fix it right now, so I'm leaving it `boolean`. Added a story below to fix it.

Each method will create a `PrismaClient`, do whatever it needs to do, and disconnect the client. That's inefficient, but it's easy for now. Added a story to make it better.

### Test it

[x] Use `CreateBackupRequestUseCase.spec.ts`. Change the success case to use the new repo. Will write data to the database?
   * [Jest docs for `spyOn`](https://jestjs.io/docs/jest-object#jestspyonobject-methodname) say it calls the spied method.

Prisma isn't finding the env file, so let's try it with `dotenv-cli`.

`npx dotenv -e ./env/test.env jest`

The test is failing now. Let's put some logging in the repo for now.

The problem is in `mapToDb()`. `backupJobId` is a `UniqueIdentifier`, need to get the `idValue` to return.

The test passed. Can we see data in `test.db`?

`npx dotenv -e ./env/test.env prisma studio`

Yes, we have a backup request that looks like the test's data.

It works!

**COMMIT 5.1.1 - ADD: BackupRequest repo using Prisma**

## Mock `PrismaClient` in a unit test

I want to mock `PrismaClient` in the `...PRISMA` test I created above so I don't need to write data to the database to test my code.

See [Prisma testing docs](https://www.prisma.io/docs/guides/testing/unit-testing) for guidance.

### Research

Examples need `jest-mock-extended` so `npm install --save-dev jest-mock-extended`.
The testing guide says "@2.0.4", but I'm going with latest (2.0.6) as it should be non-breaking.

The guide offers two ways to mock `PrismaClient`--singleton and dependency injection. The difference between the patterns seems to be whether I'd pass the DI approach's `Context` object (parameter passed to functions) or the singleton approach's `prisma` object in my repo.

So, this highlights something related to the "Move `PrismaClient` create/disconnect" item. Give the repo a constructor that accepts a `PrismaClient` and use that client in the methods. (Change made.)

Given that change, I'm not seeing much difference between the two options and how they play out in code or tests. Something in the infrastructure layer will import the client or context, create the repo with the client/context, and create use cases with the repo. The singleton is easier to understand and I don't see any negatives (yet) to using it. If I find them, only test setup and infrastructure setup are affected, so I'm going with singleton until proven otherwise.

So, in `src/common/infrastructure/database`, I'm creating `prismaClient.ts`, which exports the client (`prisma`). In the infrastructure setup, I'll import it and use it to create repos. (In the DI approach, I'd import `Context`, create a variable of that type with the `prisma` member set as a `new PrismaClient()`, and I'd pass the context or `context.prisma` to repo constructors.)

For tests, I need to mock it. Prisma docs recommend setting up a `singleton.ts`, which saves some boilerplate. I'm putting it in `src/common/test-utils/prismaSingleton.ts`. That gives me a `prismaMock` export that I can pass to repo constructors. (With DI approach, I'd use `createMockContext` to get a context or `context.prisma` to pass to repo constructors.)

I also need to `mockResolvedValue` or similar on `prismaMock.<model>.<method>` for methods that matter for each test. (Same would be true with DI approach, but `mockCtx.prisma.<model>.<method>`.)

Hence my belief that both approaches are basically equal given the code architecture.

Now, let's try all this in a test. Going back to the `...PRISMA` tests, let's import `prismaMock`. First issue, I use `describe()` where the examples in Prisma docs don't, so I need to move the `beforeEach()` from `prismaSingleton.ts` into the `describe()` block, I think.

When I try to pass `prismaMock`, I'm getting a circular dependency error, which the docs only mention for the DI approach. Hmm. Maybe the issue is, I'm not importing `prismaClient.ts` in my repo. If that's is the problem, I'll flip to the DI approach so I can pass the client to the repo.

Yeah, that seems to be the issue. Okay. I'll set up the DI approach and try it instead, because I prefer passing the client to the repo constructor. And that removes the circular reference problem in the first example. So, in the infrastructure setup, I need something like `context = { prisma: new PrismaClient() }`. Because "context" could be any context (Azure Functions use them, some HTTP frameworks use them, etc.) I'm going to rename it `PrismaContext`, etc.

Everything looks okay in VS Code (no warnings). Do tests run?
Probably not because I forgot to mock returns. (lol)

Only the test that isn't testing an error before calling the repo needs the mock. I added a comment on the others so I'd remember.

Also, mocking the value for `upsert` sometimes gets an error underline in VS Code (circular reference). The code compiles and runs, so this is a VS Code issue. I commented the line so I'd remember that too.

I wanted the repo's `save()` to return the result of the `upsert()` but:
* It makes the code hard to test. I'd need to build a complete raw result. The backupRequestId is generated in the use case, so I don't know it. So when the test checks the result to see if the use case set everything up right, it would really be looking at what it passed regardless of what the use case did.
* If I do that, it opens the door for the value of the `BackupRequest` to change if something on the database changes it. That could mean the controller gets a different result than the use case thinks it has. Either I replace all the data in the use case with the result from the `save()` or I don't return the `save()` result. (Really, the database should not be changing anything behind the `BackupRequest`'s back.)

So, I'm returning the passed `BackupRequest` from `save()` if the `upsert()` succeeds.

Tests are passing and now I can mock a client. Because I'm using a mock, I don't need to disconnect the client when done.

In the application, I do need to ensure the client disconnects on failure, but not there yet.

Deleting `prismaClient.ts` and `prismaSingleton.ts` because I'm not using them.

**COMMIT: 5.1.2 - REFACTOR: mock PrismaClient in tests; change repo to work with mockable client**

## Move `PrismaClient` create/disconnect

I want to create the `PrismaClient` and disconnect from it outside the repo so the interface is more efficient.

For the application, that would happen at the beginning and as part of the shutdown.
Where should this happen for unit tests? (or should it)

## Fix `exists()` to return a `Result`

I want the repo `exists()` method to return a `Result` so I can handle database errors gracefully.

## Change all tests to use the Prisma repo implementation

I want to change all tests to use the `PrismaBackupRequestRepo` and mock `PrismaClient` so I don't need my fake repo to test.

## Build a Prisma repo for Backups

I want to build a `PrismaBackupRepo` for `Backup` data so I can write data to the database for `Backup`s.